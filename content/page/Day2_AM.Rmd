---
title: "Day 2 - AM"
output: 
  blogdown::html_page: 
    toc: true
    toc_depth: 2
    highlight: tango
    css: css/camp_style.css
    number_sections: true
    self_contained: false
    fontsize: 18pt
    monofont: Source Code Pro
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
knitr::opts_chunk$set(fig.width = 10, fig.height = 5.2) 
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

# Good morning, young Jedis! {-}
<hr>

![](../images/day2_bb8_sq.png){width="260" style="float: left; margin-right: 60px; margin-top: -10px;"}

<br>

## Day 2 morning schedule  {-}

    - Review of Day 1
    - Add a column with a condition
    - Summarize your data
    - String together many functions
    - Group or categorize your data
    - Save data

<br><br>

# Review of Day 1 {-}
<hr>



## Porg review {-}

The _poggle_ of porgs has returned to help us review the `dplyr` functions. Follow along by downloading the __porg__ data from the URL below.

```{r, eval = F}
library(readr)
porgs <- read_csv("https://itep-r.netlify.com/data/porg_data.csv")
```

<br>

```{r porg-tabs, results='asis', echo=F}
cat(readLines("porg_tabs.txt"))
```


# | `ifelse()`

<div class="quiz">
Is it? Or isn't it? 
</div>

Sometimes you may have measurements in both PPB and PPM and you only want to convert the PPB rows to PPM units. Or maybe you only want to flag the ion engines that cost less than 500 as a great buy. Either way `ifelse` is the tool for you.

## `mutate()` + `ifelse()` is powerful! {-}

![](https://vignette2.wikia.nocookie.net/starwars/images/2/24/PowerSurge-HOBS.png/revision/latest?cb=20170513041246u0026path-prefix=ja){width="480" align="center" style="margin-right: 28px;"}

<br>

Sometimes you want the value of a new column to depend on the value of an existing column, in other words you want the new value to depend on a condition. We use `ifelse()` to do this.

`ifelse( [If this thing is true] , "Do this", "Otherwise do this thing")`


<div class="well">
__For example:__
 
`ifelse( [ The M&M is ` <span style="color: red;"> `red` </span> `], "` <span style="color: red;"> `Eat it! ` </span> `", "Otherwise - Yuk! throw it out!.")`

</div>

<br>
```{r ifelse, eval = F}

library(dplyr)
library(readr)

# Get the data
scrap <- read_csv("https://itep-r.netlify.com/data/starwars_scrap_jakku.csv")

# Convert the TONS in all capital letters to title case "Tons"
# On Day 1 we did this using tolower()

scrap <- scrap %>% 
         mutate(units = ifelse(units == "TONS", "Tons", units))

```

<br>

Congratulations of galactic proportions to you. We have a clean and tidy data set. If BB8 receives new data to append, we can re-run this script and in 5 seconds we will have a cleaned up data set again!


# | `left_join()`

## Join 2 tables {-}

### `left_join(table1, table2, by = c("columns to join by"))` {-}

<br>

### Adding porg names {-}

Remember our porg friends? How rude of us not to share their names. __Wups!__

<div style="float: right; margin-left: 20px; margin-right: 20%; margin-top: 24px; width: 37%; max-width: 37%;">
![](../images/porgs/porg_names_tbl.png){}
</div>

<br><br>

Here's a table of their names.



<div style="clear: both;"></div>

<br>

__Hey now!__ That's not very helpful. Who's who? Let's join their names to the rest of the data.


![](../images/porgs/porg_join.png){style="width: 90%; max-width: 85%;"}

<br>

### __What's the result?__ {-}

![](../images/porgs/porgs_and_names.png){style="width: 85%; max-width: 85%;"}

<br><br>


## More joining

### Joining Star Wars characters {-}


![](../images/left_join_cheat.png){width="380" align="right" style="margin-top: 0px; margin-left: 40px; margin-right: 5px;"}

**left_join()** is used to add columns to your table by pulling them from another table. Imagine you have the 2 Star Wars tables below. One table includes character names and heights; the second has names and homeworlds. Since both tables share a common name column, we can join the tables together using the name columns as the joining key. 
<br>
<style type="text/css"> .table {width: 30%;} </style>

<br>

<div style="float: left;">

`starwars_heights`

```{r, echo=F, warning=F, message=F}
library(dplyr)
library(knitr)

starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Greedo"), 
                               height = c(172, 167, 202, 150, 246))       

starwars_homeworlds <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), 
                                  homeworld = c("Tatooine", "Tatooine", "Tatooine", "Alderaan", "Ryloth"))


kable(starwars_heights)

```

</div>

<div style="float: left; margin-left: 15%;">

`starwars_homeworlds`
```{r, echo =F, warning=F, message=F}
kable(starwars_homeworlds)
```

</div>

<div style="clear: both;"> </div>

<br>

__Uh oh!__ There's no "Ayla Secura" in the height table and there's no "Greedo" in the homeworld table. Can we still join the tables? Run the code below to see what happens.

<br>

```{r, warning=F, message=F, results='hide', echo=T}
library(dplyr)
   
# Create new tables 
starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Greedo"), 
                               height = c(172,167,202,150, 246))      

starwars_homeworlds <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), 
                                  homeworld = c("Tatooine","Tatooine","Tatooine", "Alderaan", "Ryloth"))

# Join the tables together by starwars_name
## Tell left_join which columns to use as the key with:  by = c("key_left" = "key_right")
height_and_homeworld <- left_join(starwars_heights, starwars_homeworlds, 
                                  by = c("starwars_name" = "starwars_name"))

height_and_homeworld
```

<br>

```{r, echo = F}
kable(height_and_homeworld)
```

<br>

Did it work? When **left_join** added the height column to the *starwars_homeworlds* table it only entered a value for the homeworld when the tables had a matching Star Wars character name. So when R couldn't find "Greedo" in the homeworld table, the Star Wars character's homeworld was recorded as _NA_.  

<br>

Now let's imagine that the `starwars_height` table has two characters named _Darth Vader_ with different heights. What will happen when you join the tables?

<br>

```{r, echo=F}
kable(data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Darth Vader", "Leia Organa", "Greedo"), 
                 height  = c(172, 167, 202, 246, 150, 173)))
```

<br>

When you run the code below you'll see that **left_join** is very thorough and adds each height it finds for _Darth Vader_ as a new row in the joined table. 

```{r, warning=F, message=F, results='hide'}
# Create new tables 
starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Darth Vader", "Leia Organa", "Greedo"), 
                               height  = c(172,167,202,246, 150, 173))


starwars_homeworlds   <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), 
                                    homeworld = c("Tatooine","Tatooine","Tatooine", "Alderaan", "Ryloth"))

# Join the tables together by Star Wars character name
height_and_homeworld <- left_join(starwars_heights, starwars_homeworlds, 
                                  by = c("starwars_name" = "starwars_name" ))

# Check number of rows
nrow(height_and_homeworld)

height_and_homeworld
```

<br>

```{r, echo = F}
kable(height_and_homeworld)
```

<br>

<div class="note">
This results in a table with one extra row than we had before. So growing table sizes are a good sign of duplicate values when you're using **left_join**. In practice, when you see this you'll want to investigate why one of your tables has duplicate entries, especially if the observation for the two rows is different (like _Darth Vader's_ age). 

In this situation, we'd want to find out whether we really had two Star Wars characters named _Darth Vader_, or if someone made two different guesses about _Darth Vader's_ age. 

</div>

# | Back to Jakku!

__That's enough scuttlebutt, we have actual work to do and need to help Rey.__

__BB8 found a scrap mass conversion table from his droid buddies.__ How does BB8 keep doing that!? If we join our scrap data to the conversion table we can really start digging into what would be most profitable for Rey. And we can do that much more efficiently now that we know `left_join()`!  


## Read the conversion table from the Galactic interwebs {-}

```{r read-convert, eval = T, message = F}

library(readr)

# The data's url
convert_url <- "https://itep-r.netlify.com/data/conversion_table.csv"

# Read in the conversion data
convert <- read_csv(convert_url)

head(convert, 3)
```


<br>

```{r join-convert, eval=T}

library(readr)
library(dplyr)

# Read in the larger scrap database
# Note this data set has items that are in units other than tons. 

scrap <- read_csv("https://itep-r.netlify.com/data/starwars_scrap_jakku_full.csv")

# Run the following code to investigate what units are in the dataset.
unique(scrap$units)


# Join the scrap to the conversion table
scrap <- left_join(scrap, convert, by = c("item" = "item", "units" = "units"))

# Since our column names are the same, left_join will find the matching column names
# AND R tells you what columns it joined.
scrap <- left_join(scrap, convert)

head(scrap, 5)

```


<br>

__Help!__ Remember to type `?left_join` if you are wondering what the arguments are.


#### <i class="fa fa-cogs" aria-hidden="true" style="color: green"></i> Exercise {-}

```{r exer-tabs, results='asis', echo=F}
source("insert_tabs.R")

tabs <- c("Total credits", "Show hint", "Show code")

content <- c(Exercise = '<h4> Total credits </h4>

We now have the amounts sold, we know how much of that amount is in pounds, and we know the the credits per pound. We want to know the total amount of credits for each transaction. How can we calculate that?

code_start

# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(_______ = _______________)
         
code_end',

show_hint = '<h4> Total credits </h4>

We need to do some serious multiplication. We now have the amount sold, the conversion to pounds, and the credits per pound, but we want to know the total amount of credits for each transaction. How would we calculate that?

code_start

# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(credits = _______ * _______ * ________)

code_end',

show_code = '<h4> Total credits </h4>

We need to do some serious multiplication. We now have the amount sold, the conversion to pounds, and the credits per pound, but we want to know the total amount of credits for each transaction. How would we calculate that?

code_start

# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(credits = amount * pounds * price_per_pound)
         
code_end')

tab_html <- add_tabs(tabs, content)

cat(paste0(tab_html, collapse = "\n"))
```

<br>

<div class="note">

Data analysts often get asked questions similar to:

- What's the highest number? 
- What's the lowest number? 
- So what's the average tonnage of scrap from Cratertown this year? 
- Who's making the most money this year?

So, let us move on to `summarize()`.

</div>


# | `summarize()` this
<hr>

![](../images/summarize_diagram.png){width="490"}

`summarize()` allows you to apply a summary function like `median()` to a column and collapse your data down to a single row. To really dig into `summarize` you'll want to know some common summary functions, such as `sum()`, `mean()`, `median()`, `min()`, and `max()`.



## `sum()` {-}

Use `summarize()` and `sum()` to find the total credits from all the scrap.

```{r, eval = F}
summarize(scrap, total_credits = sum(credits))
```


## `mean()` {-}
Use `summarize()` and `mean()` to calculate the _mean_ `price_per_pound` in the scrap report.

```{r, eval = F}

summarize(scrap, mean_price = mean(price_per_pound, na.rm = T))

```

<br>

> Note the `na.rm = TRUE` in the `mean()` function. This tells R to ignore empty cells or missing values that show up in R as `NA`. If you leave `na.rm` out, the _mean_ function will return 'NA' if it finds a missing value in the data.


## `median()` {-}
Use summarize to calculate the _median_ price_per_pound in the scrap report.

`summarize(scrap, median_price = median(price_per_pound, na.rm = T))`

## `max()` {-}
Use summarize to calculate the _maximum_ price per pound any scrapper got for their scrap.

`summarize(scrap, max_price = max(price_per_pound, na.rm = T))`

## `min()` {-}
Use summarize to calculate the _minimum_ price per pound any scrapper got for their scrap.

`summarize(scrap, min_price = min(price_per_pound, na.rm = T))`

## `nth()` {-}
Use `summarize()` and `nth(Origin, 12)` to find the name of the Origin City that got the  _12th_ highest scrapper haul.   

_Hint: Use `arrange()` first._

`arrange(scrap, desc(credits)) %>% summarize(price_12 = nth(origin, 12))`

## `sd()` {-}

What is the _standard deviation_ of the credits?

`summarize(scrap, stdev_credits = sd(credits))`

## `quantile()` {-}

_Quantiles_ are useful for finding the upper or lower range of a column. Use the `quantile()` function to find the the 5th and 95th quantile of the prices.

```{r quants, eval = FALSE}

summarize(scrap, 
          price_5th_pctile  = quantile(price_per_pound, 0.05, na.rm = T),
          price_95th_pctile = quantile(price_per_pound, 0.95))
```


__Hint:__ Add `na.rm = T` to `quantile()`.


## `n()` {-}

`n()` stands for _count_.

Use summarize and `n()` to count the number of reported scrap records going to `Niima outpost`. 

__Hint:__ Use `filter()` first.

<br>

```{r, eval=F}
niima_scrap <- filter(scrap, destination == "Niima Outpost") 

niima_scrap <- summarize(niima_scrap, scrap_records = n())

```

<br>


### <i class="fa fa-starwars" aria-hidden="true" style="color: green"></i> Exercise {-}

Create a summary of the scrap data that includes 3 of the summary functions above. The following is one example.

```{r, eval = F}

summary <- summarize(scrap, 
                     max_credits      = __________,
                     weight_90th_pct  = quantile(Weight, 0.90),
                     count_records    = __________,
                     
```

<br>

What if I want to string several of these data processing functions together? Do I have to keep writing `scrap` so many times? I mean I have now written __scrap__ like a million times and my fingers hurt. Mother of moons! I have rebels to protect and I haven't eaten in 2 days!


# | The pipe `%>%`

__Let the `%>%` guide you young Padawan.__

![](https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/9302/medium/1447173978/rstudio-hex-pipe-dot-psd.png){width="155" align="left" style="margin-right: 28px; margin-bottom: 22px;"}

<br>

Luckily, you __don't__ have to do ALL that typing. The pipe let's you can chain functions together and do everything in one go. 

<br>

<div style="clear:both;"></div>

```{r pipe-time, eval = F}

my_scrap <- scrap %>%
            filter(item == "Acceleration compensator") %>%
            arrange(desc(amount))

```


<br>


> __Shut me down!__ 
>
> That was a whole lot of summarizing. Do we really have to filter to the Origin City that we're interested in every time? 
>
> It sure would be nice if we could easily find the mean price for every Origin City. Then we could summarize once and be done with it.

<br>


### It's time for `group_by()`! {-}


# | `group_by()`
<hr>

## Bargain hunters {-}

Who's selling goods for cheap? Use `group_by` with the column _Origin_, and then use`summarize` to find the `mean(price_per_pound)` at each Origin City. 

```{r mean_price-by-origin, eval = F}

scrap_summary <- group_by(scrap, origin) %>% 
                 summarize(mean_price =  mean(price_per_pound, na.rm = T)) 

```


<br>


<details>
<summary class="btn_code_blue"> Rounding digits </summary>

<div class="note">
<p>
You can round the prices to a certain number of digits using the `round()` function. We can finish by adding the `arrange()` function to sort the table by our new column.

```{r mean_price-by-Origin-round, eval = F}

scrap_means <- group_by(scrap, origin) %>% 
                 summarize(mean_price       =  mean(price_per_pound, na.rm = T),
                           mean_price_round = round(mean_price, digits = 2)) %>%  
                 arrange(mean_price_round) %>%
                 ungroup()

```

<br>


__NOTE:__ 

The `round()` function in R does not automatically round values ending in 5 up. Instead it uses scientific rounding, which rounds values ending in 5 to the nearest even number. So 2.5 rounded to the nearest whole number rounds down to 2, and 3.5 rounded to the nearest whole number rounds up 4.

</p>
</div>
</details>


<br>

Who's making lots of transactions? Try using `group_by` with the column _origin_ and then `summarize` to count the number of scrap records at each city.  

```{r grp-by-origin, eval = FALSE}

scrap_counts <- group_by(scrap, origin) %>% 
                summarize(origin_count  =  n()) %>% 
                ungroup()

```


<br>

### <i class="fa fa-user-astronaut" aria-hidden="true" style="color:#040707;"></i> Pro-tip! {-}
<div class="well">

Ending with `ungroup()` is good practice. This prevents your data from staying grouped after the summarizing has been completed.

</div>


# | Save files
<hr>

Let's save the mean price summary table we created to a _CSV_. That way we can transfer it to a _droid courier_ for delivery to Rey. To save a data frame we can use the `write_csv()` function from our favorite `readr` package. 

```{r, eval = F}

# Write the file to your results folder
write_csv(scrap_summary, "results/prices_by_origin.csv")

```

<br>

### <i class="fa fa-user-astronaut" aria-hidden="true" style="color:#040707;"></i> __Warning!__ {-}
<div class="well">

By default, when saving R will overwrite a file if the file already exists in the same folder. It will not ask for confirmation. To be safe, save processed data to a new folder called `results/` and not to your raw `data/` folder.

</div>


# | Grouped `mutate()` 
<br><hr>

We can bring back `mutate` to add a column based on the grouped values in a data set. For example, you may want to add a column showing the mean price by origin to the whole table, but still keep all of the records. This is a good way to add values to the table to serve as a reference point. 

> How does the price of Item X compare to the average price?  

When you combine `group_by` and `mutate` the new column will be calculated based on the values within each group. Let's group by `origin` to find the `mean()` price per pound at each origin. 

<br>

```{r mutate-price, eval=F}

scrap <- group_by(scrap, origin) %>% 
            mutate(origin_mean_price = mean(price_per_pound, na.rm = T)) %>% 
            ungroup()
```

<br>

### <i class="fa fa-rocket" aria-hidden="true"></i> Return to [Homebase](../post/day-2.html) {-}

<br>

