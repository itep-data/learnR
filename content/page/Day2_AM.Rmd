---
title: "Day 2 - AM"
output: 
  blogdown::html_page: 
    toc: true
    toc_depth: 2
    highlight: tango
    css: css/camp_style.css
    number_sections: true
    self_contained: false
    fontsize: 18pt
    monofont: Source Code Pro
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F)
knitr::opts_chunk$set(fig.width = 10, fig.height = 5.2) 
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

# Good morning, young Jedis! {-}
<hr>

![](../images/day2_bb8_sq.png){width="260" style="float: left; margin-right: 60px; margin-top: -10px;"}

<br>

## Day 2 morning schedule  {-}

    - Review of Day 1
    - Add a column with a condition
    - Summarize your data
    - String together many functions
    - Group or categorize your data
    - Save data

<br><br>

# Review of Day 1 {-}
<hr>

## Porg review {.tabset -}

The _poggle_ of porgs will once again help us review the `dplyr` functions. Follow along by downloading the __porg__ data from the URL below.

```{r, eval = F}
library(readr)
porgs <- read_csv("https://itep-r.netlify.com/data/porg_data.csv")

```


## `porgs` {-}

![](../images/porgs/porgs_tbl.png){style="width: 85%;"}

<br><hr><br>

## `select`    {-}

![](../images/porgs/select.png){style="width: 65%;"}

![](../images/porgs/select_tbl.png){style="width: 88%; margin-left: 10%; margin-top: 12px;"}

<br><br>

![](../images/porgs/select_drop.png){style="width: 65%;"}

![](../images/porgs/select_drop_tbl.png){style="width: 80%; margin-left: 5%; margin-top: 12px;"}

<br><hr><br>

## `arrange`   {-}

![](../images/porgs/arrange.png){style="width: 65%;"}

![](../images/porgs/arrange_tbl.png){style="width: 88%; margin-left: 10%; margin-top: 12px;"}

<br><br>

![](../images/porgs/arrange_desc.png){style="width: 57%;"}

![](../images/porgs/arrange_tbl_desc.png){style="width: 88%; margin-left: 10%; margin-top: 12px;"}

<br><hr><br>

## `filter`    {-}

![](../images/porgs/filter.png){style="width: 65%;"}

![](../images/porgs/filter_tbl.png){style="width: 88%; margin-left: 10%; margin-top: 12px;"}

<br><br>

![](../images/porgs/filter2.png){style="width: 75%;"}

![](../images/porgs/filter2_tbl.png){style="width: 88%; margin-left: 10%; margin-top: 12px;"}


<br><hr><br>

## `mutate`    {-}

![](../images/porgs/mutate.png){style="width: 77%;"}

<br>

![](../images/porgs/mutate_tbl.png){style="width: 88%; margin-left: 4%; margin-top: 12px;"}

<br><hr><br>

## `summarize` {-}

![](../images/porgs/summarize.png){style="width: 77%;"}

<br>

![](../images/porgs/summarize_tbl.png){style="width: 88%; margin-left: 4%; margin-top: 12px;"}

<br><hr><br>

## `group_by`  {-}

![](../images/porgs/groupby.png){style="width: 77%;"}

<br>

![](../images/porgs/groupby_tbl.png){style="width: 94%; margin-left: 2%; margin-top: 12px;"}

<br><hr><br>


# | `ifelse()`

Maybe you have measurements in both PPB and PPM and you only want to convert the PPB rows to PPM units. Or maybe you only want to flag the ion engines that cost less than 500 as a great buy. Either way `ifelse` is the tool for you.

## `mutate()` + `ifelse()` is powerful! {-}

![](https://vignette2.wikia.nocookie.net/starwars/images/2/24/PowerSurge-HOBS.png/revision/latest?cb=20170513041246u0026path-prefix=ja){width="480" align="center" style="margin-right: 28px;"}

<br>

Sometimes you want the value of a new column to depend on the value of an existing column, in other words you want the new value to depend on a condition. We use `ifelse()` to do this.

`ifelse( [If this thing is true] , "Do this", "Otherwise do this thing")`


> __For example:__
>
> `ifelse( [ The M&M is red ], "Eat it!", "Otherwise - Yuk! throw it out!.")`


<br>
```{r ifelse, eval = F}

library(dplyr)
library(readr)

#Get the data
scrap <- read_csv("https://itep-r.netlify.com/data/starwars_scrap_jakku.csv")

# Convert the TONS in all capital letters to title case "Tons"
# On Day 1 we did this using tolower()

scrap <- scrap %>% 
         mutate(units = ifelse(units == "TONS", "Tons", units))

```

<br>

Congratulations of galactic proportions to you. We have a clean and tidy data set. If BB8 receives new data to append, we can re-run this script and in 5 seconds we will have a cleaned up data set again!


# | `left_join()`

## Join 2 tables {-}

### `left_join(table1, table2, by = c("columns to join by"))` {-}

<br>

![](../images/left_join_image.png){style="width: 85%; max-width: 85%;"}

<br><br>

__BB8 found a unit converter table while surfing the web.__ How does BB8 keep doing that!? If we join our scrap data to the unit converter table we can really start digging into what would be most profitable for Rey. First, let's talk about `left_join()`.

<br>

## Joining Star Wars characters {-}


![](../images/left_join_cheat.png){width="380" align="right" style="margin-top: -30px; margin-left: 40px; margin-right: 5px;"}

**left_join()** is used to add columns to your table. Imagine you have the 2 Star Wars tables below. One is a table includes character names and heights; the second names and homeworlds. Since both tables share a common name column, we can join the tables together using the name columns as the joining key. 
<br>
<style type="text/css"> .table {width: 30%;} </style>

<br>

`starwars_heights`

```{r, echo=F, warning=F, message=F}
library(dplyr)
library(knitr)

starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Greedo"), 
                               height = c(172, 167, 202, 150, 246))       

starwars_homeworlds <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), 
                                  homeworld = c("Tatooine", "Tatooine", "Tatooine", "Alderaan", "Ryloth"))


kable(starwars_heights)

```

`starwars_homeworlds`
```{r, echo =F, warning=F, message=F}
kable(starwars_homeworlds)
```

<br>

__Uh oh!__ There's no "Ayla Secura" in the height table and there's no "Greedo" in the homeworld table. Can we still join the tables? Run the code below to see what happens.

<br>

```{r, warning=F, message=F, results='hide', echo=F}
library(dplyr)
   
# Create new tables 
starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Greedo"), height = c(172,167,202,150, 246))      

starwars_homeworlds   <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), homeworld = c("Tatooine","Tatooine","Tatooine", "Alderaan", "Ryloth"))

# Join the tables together by starwars_name
## Tell left_join which columns to use as the key with:  by = c("key_left" = "key_right")
height_and_homeworld <- left_join(starwars_heights, starwars_homeworlds, by = c("starwars_name" = "starwars_name"))

height_and_homeworld
```


```{r, echo = F}
kable(height_and_homeworld)
```

<br>

Did it work? When **left_join** added the height column to the *starwars_homeworlds* table it only entered a value for the homeworld when the tables had a matching Star Wars character name. So when R couldn't find "Greedo" in the homeworld table, the Star Wars character's homeworld was recorded as _NA_.  

<br>

Now let's imagine that the `starwars_height` table has two characters named _Darth Vader_ with different heights. What will happen when you join the tables?

<br>

```{r, echo=F}
kable(data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Darth Vader", "Leia Organa", "Greedo"), height  = c(172, 167, 202, 246, 150, 173)))
```

<br>

When you run the code below you'll see that **left_join** is very thorough and adds each height it finds for _Darth Vader_ as a new row in the joined table. 

```{r, warning=F, message=F, results='hide'}
# Create new tables 
starwars_heights <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Darth Vader", "Leia Organa", "Greedo"), height  = c(172,167,202,246, 150, 173))


starwars_homeworlds   <- data_frame(starwars_name = c("Luke Skywalker", "C-3PO", "Darth Vader", "Leia Organa", "Ayla Secura"), homeworld = c("Tatooine","Tatooine","Tatooine", "Alderaan", "Ryloth"))

# Join the tables together by Star Wars character name
height_and_homeworld <- left_join(starwars_heights, starwars_homeworlds, by = c("starwars_name" = "starwars_name" ))

# Check number of rows
nrow(height_and_homeworld)

height_and_homeworld
```


```{r, echo = F}
kable(height_and_homeworld)
```

<br>

<div class="note">
This results in a table with one extra row than we had before. So growing table sizes are a good sign of duplicate values when you're using **left_join**. In practice, when you see this you'll want to investigate why one of your tables has duplicate entries, especially if the observation for the two rows is different (like _Darth Vader's_ age). 

In this situation, we'd want to find out whether we really had two Star Wars characters named _Darth Vader_, or if someone made two different guesses about _Darth Vader's_ age. 

</div>

<br>

__Back to the scrap data! We don't have time for scuttlebutt, we have actual work to do and need to help Rey.__ BUT, we can do that way more efficiently now that we know `left_join()`! Remember that BB8 found a unit converter table while surfing the web. If we join our scrap data to the unit converter table we can start really digging into what would be most profitable for Rey. 

## Getting data directly from the internet {-}

```{r read-convert, eval = T, message = F}

library(readr)

# The data's url
convert_url <- "https://itep-r.netlify.com/data/conversion_table.csv"

# Read in the conversion data
convert <- read_csv(convert_url)

head(convert, 3)
```


<br>

```{r join-convert, eval = T}

library(readr)
library(dplyr)

# Read in the larger scrap database
# Note this data set has items that are in units other than tons. 

scrap <- read_csv("https://itep-r.netlify.com/data/starwars_scrap_jakku_full.csv")

# Run the following code to investigate what units are in the dataset.
unique(scrap$units)


# Join the scrap to the conversion table
scrap <- left_join(scrap, convert, by = c("item" = "item", "units" = "units"))

# Since our column names are the same, left_join will find the matching column names
# AND R tells you what columns it joined.
scrap <- left_join(scrap, convert)

head(scrap, 5)

```


<br>

__Help!__ Remember to type `?left_join` if you are wondering what the arguments are.


### <i class="fa fa-starwars" aria-hidden="true" style="color: green"></i> Exercise {.tabset}

#### Total price {-}

We now have the amounts sold, we know how much of that amount is in pounds, and we know the the price per pound. We want to know the total amount of credits for each transaction. How would we calculate that?

<br>
```{r, eval=F}

# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(_______ = _______________)
```


#### Show hint {-}

__Total price__

We now have the amount sold, the conversion to pounds, and the price per pound, but we want to know the total amount of credits for each transaction. How would we calculate that?

<br>
```{r, eval=F}
# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(credits = _______ * _______ * ________)

```

#### Show code {-}

__Total price__

We now have the amount sold, the conversion to pounds, and the price per pound, but we want to know the total amount of credits for each transaction. How would we calculate that?

<br>
```{r, eval = F}
# Calculate the total credits for each transaction
scrap <- scrap %>% 
         mutate(credits = amount * pounds * price_per_pound)

```

<br><br><hr>



We as data analysts often get questions like, What's the highest number? What's the lowest number? What is the mean tonnage from Cratertown? So, let us move on to `summarize()`.


# | `summarize()` this
<hr>

![](../images/summarize_diagram.png){width="490"}

`summarize()` allows you to apply a summary function like `median()` to a column and collapse your data down to a single row. To really dig into `summarize` you'll want to know some common summary functions, such as `sum()`, `mean()`, `median()`, `min()`, and `max()`.



## `sum()` {-}

Use `summarize()` and `sum()` to find the total credits from all Salvage.

```{r, eval = F}
summarize(scrap, total_credits = sum(credits))
```


## `mean()` {-}
Use `summarize()` and `mean()` to calculate the _mean_ price_per_pound in the Salvage report.

```{r, eval = F}

summarize(scrap, mean_price = mean(price_per_pound, na.rm = T))

```

<br>

> Note the `na.rm = TRUE` in the `mean()` function. This tells R to ignore empty cells or missing values that show up in R as `NA`. If you leave `na.rm` out, the _mean_ function will return 'NA' when it finds a missing value in the data.


## `median()` {-}
Use summarize to calculate the _median_ price_per_pound in the Salvage report.

`summarize(scrap, median_price = median(price_per_pound, na.rm = T))`

## `max()` {-}
Use summarize to calculate the _maximum_ price per pound any scrapper got for their Salvage.

`summarize(scrap, max_price = max(price_per_pound, na.rm = T))`

## `min()` {-}
Use summarize to calculate the _minimum_ price per pound any scrapper got for their Salvage.

`summarize(scrap, min_price = min(price_per_pound, na.rm = T))`

## `nth()` {-}
Use `summarize()` and `nth(Origin, 12)` to find the name of the Origin City that got the  _12th_ highest scrapper haul.   

_Hint: Use `arrange()` first._

`arrange(scrap, desc(credits)) %>% summarize(price_12 = nth(origin, 12))`

## `sd()` {-}

What is the _standard deviation_ of the credits?

`summarize(scrap, stdev_credits = sd(credits))`

## `quantile()` {-}

_Quantiles_ are useful for finding the upper or lower range of a column. Use the `quantile()` function to find the the 5th and 95th quantile of the prices.

```{r quants, eval = FALSE}

summarize(scrap, 
          price_5th_pctile  = quantile(price_per_pound, 0.05, na.rm = T),
          price_95th_pctile = quantile(price_per_pound, 0.95))
```

_Hint: add `na.rm = T` to `quantile()`._


## `n()` {-}

`n()` stands for _count_.

Use summarize and `n()` to count the number of reported Salvage records going to a Niima outpost. 

_Hint: Use `filter()` first._  

```{r, eval = F}
niima_scrap <- filter(scrap, destination == "Niima Outpost") 
niima_scrap <- summarize(niima_scrap, salvage_records = n())

```

<br>


### <i class="fa fa-starwars" aria-hidden="true" style="color: green"></i> Exercise {-}

Create a summary of the scrap data that includes 3 of the summary functions above. The following is _just_ an example.

```{r, eval = F}

summary <- summarize(scrap, 
                     max_credits      = __________,
                     weight_90th_pct  = quantile(Weight, 0.90),
                     count_records    = __________,
                     
```

<br>
What if I want to string several of these data processing functions together? Do I have to keep writing __scrap__ so many times? I have now written __scrap__ like a million times and I am sick of it. Mother of moons! I have rebels to protect and I haven't eaten in 2 days!

<br>

# | The pipe `%>%`

__Use the `%>%` young Padawan.__

![](https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/9302/medium/1447173978/rstudio-hex-pipe-dot-psd.png){width="155" align="left" style="margin-right: 28px;"}

<br>

Luckily, you __don't__ have to do ALL that typing. The pipe let's you can chain functions together and do everything in one go. 

<br><br>

```{r pipe-time, eval = F}

my_scrap <- scrap %>%
            filter(item == "Acceleration compensator") %>%
            arrange(desc(amount))

```



# | `group_by()`
<hr>

> Wouldn't it be nice if we could easily find the mean price at every Origin City? Let's really wookie this thing. It's time for `group_by()`!

<br>

Use `group_by` with the column _Origin_ again, but this time use `summarize` to find the `mean(price_per_pound)` for each Origin City. 

```{r mean_price-by-origin, eval = F}

scrap_summary <- group_by(scrap, origin) %>% 
                 summarize(mean_price =  mean(price_per_pound, na.rm = T)) 

```


<br>


<details><summary class="btn_code"> Rounding digits </summary><p>

You can round the prices to a certain number of digits using the `round()` function. We can finish by adding the `arrange()` function to sort the table by our new column.

```{r mean_price-by-Origin-round, eval = F}

scrap_means <- group_by(scrap, origin) %>% 
                 summarize(mean_price       =  mean(price_per_pound, na.rm = T),
                           mean_price_round = round(mean_price, digits = 2)) %>%  
                 arrange(mean_price_round) %>%
                 ungroup()

```

<br>

__NOTE:__ The `round()` function in R does not automatically round values ending in 5 up, instead it uses scientific rounding. It rounds values ending in 5 to the nearest even number, so 2.5 rounded to the nearest whole number using `round()` is 2, and 3.5 rounded to the nearest whole number is 4. If you want to round all values ending in 5 up, then you'll have to use a rounding function from another package.

</p></details>


<br>

Try using `group_by` with the column _origin_ and then use `summarize` to count the number of Salvage reports from each city.  

```{r grp-by-origin, eval = FALSE}

scrap_counts <- group_by(scrap, origin) %>% 
                summarize(origin_count  =  n()) %>% 
                ungroup()

```


<br>

### <i class="fa fa-user-astronaut" aria-hidden="true" style="color:#040707;"></i> Pro-tip! {-}
> Ending with `ungroup()` is good practice. This will prevent your data from staying grouped after the summarizing has been completed.



# | Save files
<hr>

Let's save the mean price summary table we created to a _CSV_. That way we can print it to have it __transmitted through Droid courier__ to Rey. To save a data frame we'll use the `write_csv()` function from our favorite _readr_ package. 

```{r, eval = F}

# Write the file to your results folder
write_csv(scrap_means, "results/Mean_prices_by_origin.csv")

```



### <i class="fa fa-user-astronaut" aria-hidden="true" style="color:#040707;"></i> Pro-tip! {-}
> __Warning!__ By default, R will overwrite a file if the file already exists in a folder. It will not ask for confirmation. To be safe, do not save processed data to your `data/` folder.
>

<br>


# | Grouped `mutate()` 
<br><hr>

We can bring back `mutate` to add a column based on the grouped values in a data set. For example, you may want to add a column showing the mean price by country to the whole table.  

When you combine `group_by` and `mutate` the new column will be calculated based on the values within each group. 

```{r mutate-price, eval = F}

group_by(scrap, origin) %>% mutate(origin_mean_price = mean(price_per_pound, na.rm = T)) %>% ungroup()

```

<br>

### <i class="fa fa-rocket" aria-hidden="true"></i> Return to [Homebase](../post/day-2.html) {-}

<br>

